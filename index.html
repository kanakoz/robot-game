<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>テント飲食出店レイアウト3D（初期値反映版）</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif; touch-action: none; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            pointer-events: none;
            z-index: 100;
            max-width: 80%;
        }
        h1 { font-size: 16px; margin: 0 0 5px 0; }
        p { font-size: 12px; margin: 0; }
        #liff-status {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <!-- LIFF SDK -->
    <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
</head>
<body>
    <div id="info">
        <h1>出店レイアウト 3Dシミュレーター</h1>
        <p>オブジェクトをドラッグして移動できます。</p>
        <p>左ドラッグ: 回転/移動 | 右ドラッグ: 移動</p>
        <div id="liff-status">LIFF初期化待機中...</div>
    </div>

    <script>
        // --- LIFF設定 ---
        const LIFF_ID = ""; 

        // --- 設定変数 (cm単位) ---
        const SPACE_WIDTH = 360;
        const SPACE_DEPTH = 360;
        const SPACE_HEIGHT = 250;
        const PERSON_HEIGHT = 170;
        const PERSON_RADIUS = 25;
        const WORK_RADIUS = 60;

        // --- 初期データ (Config: ユーザー提供データを反映) ---
        const furnitureData = {
          luggage: { label: "荷物", w: 49.23, d: 46.62, h: 100, x: -152.82, z: -155.14, color: 8421504 },
          tableLeftBack: { label: "テーブルA", w: 60, d: 120, h: 70, x: -150, z: -120, color: 3355443 },
          tableLeftFront: { label: "テーブルB", w: 60, d: 120, h: 70, x: -150.02, z: 2.80, color: 3355443 },
          deskFront: { label: "長机A", w: 180, d: 60, h: 70, x: -8.44, z: 138.93, color: 9127187 },
          deskRight: { label: "長机B", w: 60, d: 180, h: 70, x: 148.84, z: 57.96, color: 9127187 },
          deskBack: { label: "長机C", w: 180, d: 60, h: 70, x: 45.58, z: -94.94, color: 9127187 }
        };

        const peopleData = [
          { label: "人A", x: -16.45, z: 73.63 },
          { label: "人B", x: -77.48, z: -30.36 },
          { label: "人C", x: -72.88, z: -145.78 },
          { label: "人D", x: 64.38, z: 7.53 },
          { label: "人E", x: 87.39, z: -151.48 },
          { label: "人F", x: -133.66, z: 139.11 }
        ];

        let scene, camera, renderer, controls;
        let walls = [];
        let workZones = [];
        
        // オブジェクト管理用
        const furnitureGroups = {}; 
        const peopleGroups = [];
        let draggableObjects = []; 

        // ドラッグ用変数
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;
        let dragPlane = new THREE.Plane();
        let dragOffset = new THREE.Vector3();
        let isDragging = false;

        async function init() {
            await initializeLiff();

            // 1. シーンセットアップ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe0e0e0);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(0, 500, 500);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 2. 照明
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(100, 300, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);

            // 3. 環境構築
            createEnvironment();
            
            // 4. オブジェクト配置
            placeFurnitureDynamic();
            placePeopleDynamic();

            // 5. GUI構築
            setupGUI();

            // 6. イベントリスナー
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        async function initializeLiff() {
            const statusDiv = document.getElementById('liff-status');
            if (!LIFF_ID) {
                statusDiv.innerText = "LIFF ID未設定 (Webモード)";
                return;
            }
            try {
                await liff.init({ liffId: LIFF_ID });
                if (liff.isLoggedIn()) {
                    const profile = await liff.getProfile();
                    statusDiv.innerText = `LIFF: ${profile.displayName}でログイン中`;
                } else {
                    statusDiv.innerText = "LIFF: 未ログイン";
                }
            } catch (error) {
                console.error('LIFF Initialization failed', error);
                statusDiv.innerText = "LIFF初期化エラー";
            }
        }

        function createEnvironment() {
            const gridHelper = new THREE.GridHelper(SPACE_WIDTH + 200, 20);
            scene.add(gridHelper);

            const floorGeo = new THREE.PlaneGeometry(SPACE_WIDTH, SPACE_DEPTH);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
            
            const wallLeft = new THREE.Mesh(new THREE.PlaneGeometry(SPACE_DEPTH, SPACE_HEIGHT), wallMat);
            wallLeft.position.set(-SPACE_WIDTH / 2, SPACE_HEIGHT / 2, 0);
            wallLeft.rotation.y = Math.PI / 2;
            scene.add(wallLeft);
            walls.push(wallLeft);

            const wallRight = new THREE.Mesh(new THREE.PlaneGeometry(SPACE_DEPTH, SPACE_HEIGHT), wallMat);
            wallRight.position.set(SPACE_WIDTH / 2, SPACE_HEIGHT / 2, 0);
            wallRight.rotation.y = -Math.PI / 2;
            scene.add(wallRight);
            walls.push(wallRight);

            const wallBack = new THREE.Mesh(new THREE.PlaneGeometry(SPACE_WIDTH, SPACE_HEIGHT), wallMat);
            wallBack.position.set(0, SPACE_HEIGHT / 2, -SPACE_DEPTH / 2);
            scene.add(wallBack);
            walls.push(wallBack);

            const boxGeo = new THREE.BoxGeometry(SPACE_WIDTH, SPACE_HEIGHT, SPACE_DEPTH);
            const line = new THREE.LineSegments(new THREE.EdgesGeometry(boxGeo), new THREE.LineBasicMaterial({ color: 0x333333 }));
            line.position.y = SPACE_HEIGHT / 2;
            scene.add(line);
        }

        function createTextTexture(text, textColor, backgroundColor) {
            const canvas = document.createElement('canvas');
            const size = 512;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            if (backgroundColor) {
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, size, size);
            } else {
                ctx.fillStyle = 'rgba(0,0,0,0)';
                ctx.clearRect(0, 0, size, size);
            }

            ctx.fillStyle = textColor;
            ctx.font = 'bold 60px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size / 2, size / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function placeFurnitureDynamic() {
            const baseGeo = new THREE.BoxGeometry(1, 1, 1);
            for (const key in furnitureData) {
                const data = furnitureData[key];
                
                const group = new THREE.Group();
                
                const mat = new THREE.MeshStandardMaterial({ color: data.color });
                const mesh = new THREE.Mesh(baseGeo, mat);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { isFurniturePart: true, parentId: key };
                group.add(mesh);
                
                const textTexture = createTextTexture(data.label, '#000000', null);
                const spriteMaterial = new THREE.SpriteMaterial({ map: textTexture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(60, 60, 1);
                group.add(sprite);

                group.userData = { isFurniture: true, id: key, mesh: mesh, sprite: sprite };
                
                scene.add(group);
                furnitureGroups[key] = group;
                draggableObjects.push(mesh);

                updateFurnitureMesh(key);
            }
        }

        function updateFurnitureMesh(key) {
            const data = furnitureData[key];
            const group = furnitureGroups[key];
            if (!group) return;

            const mesh = group.userData.mesh;
            const sprite = group.userData.sprite;

            group.position.set(data.x, 0, data.z);

            mesh.scale.set(data.w, data.h, data.d);
            mesh.position.y = data.h / 2;

            sprite.position.y = data.h + 30;
        }

        function placePeopleDynamic() {
            peopleData.forEach((pData, index) => {
                const group = new THREE.Group();
                group.userData = { isPerson: true, index: index };

                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(PERSON_RADIUS, PERSON_RADIUS, PERSON_HEIGHT, 16),
                    new THREE.MeshStandardMaterial({ color: 0x2196f3 })
                );
                body.position.y = PERSON_HEIGHT / 2;
                body.castShadow = true;
                group.add(body);

                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(20, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xffccbc })
                );
                head.position.y = PERSON_HEIGHT;
                group.add(head);

                const textTexture = createTextTexture(pData.label, '#000000', null);
                const spriteMaterial = new THREE.SpriteMaterial({ map: textTexture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(0, PERSON_HEIGHT + 30, 0);
                sprite.scale.set(60, 60, 1); 
                group.add(sprite);
                
                const zone = new THREE.Mesh(
                    new THREE.CircleGeometry(WORK_RADIUS, 32),
                    new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
                );
                zone.rotation.x = -Math.PI / 2;
                zone.position.y = 1;
                group.add(zone);
                workZones.push(zone);

                scene.add(group);
                peopleGroups[index] = group;
                
                body.userData = { parentGroupIndex: index, isPersonPart: true };
                head.userData = { parentGroupIndex: index, isPersonPart: true };
                draggableObjects.push(body);
                draggableObjects.push(head);

                updatePersonMesh(index);
            });
        }

        function updatePersonMesh(index) {
            const data = peopleData[index];
            const group = peopleGroups[index];
            if (!group) return;
            group.position.set(data.x, 0, data.z);
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggableObjects);

            if (intersects.length > 0) {
                controls.enabled = false;
                isDragging = true;
                const hit = intersects[0];
                let object = hit.object;

                if (object.userData.isPersonPart) {
                    const index = object.userData.parentGroupIndex;
                    selectedObject = peopleGroups[index];
                } else if (object.userData.isFurniturePart) {
                    const id = object.userData.parentId;
                    selectedObject = furnitureGroups[id];
                }

                if (selectedObject) {
                    const normal = new THREE.Vector3(0, 1, 0);
                    dragPlane.setFromNormalAndCoplanarPoint(normal, hit.point);
                    dragOffset.subVectors(selectedObject.position, hit.point);
                }
            }
        }

        function onPointerMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (isDragging && selectedObject) {
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);

                if (intersectPoint) {
                    const newPos = intersectPoint.add(dragOffset);
                    selectedObject.position.x = newPos.x;
                    selectedObject.position.z = newPos.z;

                    if (selectedObject.userData.isPerson) {
                        const index = selectedObject.userData.index;
                        peopleData[index].x = newPos.x;
                        peopleData[index].z = newPos.z;
                    } else if (selectedObject.userData.isFurniture) {
                        const id = selectedObject.userData.id;
                        furnitureData[id].x = newPos.x;
                        furnitureData[id].z = newPos.z;
                    }
                }
                return;
            }

            const intersects = raycaster.intersectObjects(draggableObjects);
            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function onPointerUp(event) {
            isDragging = false;
            selectedObject = null;
            controls.enabled = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 設定出力モーダル ---
        function showExportModal() {
            const data = {
                furniture: furnitureData,
                people: peopleData
            };
            const json = JSON.stringify(data, null, 2);
            
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:999;display:flex;justify-content:center;align-items:center;';
            
            const content = document.createElement('div');
            content.style.cssText = 'background:white;padding:20px;border-radius:5px;width:80%;max-width:500px;display:flex;flex-direction:column;gap:10px;box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
            
            const label = document.createElement('p');
            label.innerText = '以下のデータを全てコピーして、AIチャットに貼り付けてください。';
            label.style.margin = '0 0 5px 0';
            label.style.fontSize = '14px';
            
            const textarea = document.createElement('textarea');
            textarea.value = json;
            textarea.style.cssText = 'width:100%;height:200px;font-family:monospace;font-size:12px;border:1px solid #ccc;padding:5px;';
            
            // コピーボタン
            const copyBtn = document.createElement('button');
            copyBtn.innerText = 'クリップボードにコピー';
            copyBtn.style.padding = '8px';
            copyBtn.style.cursor = 'pointer';
            copyBtn.onclick = () => {
                textarea.select();
                document.execCommand('copy');
                copyBtn.innerText = 'コピーしました！';
                setTimeout(() => copyBtn.innerText = 'クリップボードにコピー', 2000);
            };

            const closeBtn = document.createElement('button');
            closeBtn.innerText = '閉じる';
            closeBtn.style.padding = '8px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.onclick = () => document.body.removeChild(overlay);
            
            content.appendChild(label);
            content.appendChild(textarea);
            content.appendChild(copyBtn);
            content.appendChild(closeBtn);
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        function setupGUI() {
            const gui = new dat.GUI({ width: 300 });

            const folderGlobal = gui.addFolder('全体表示設定');
            const params = {
                wallOpacity: 0.5,
                showWorkZone: true,
                resetCamera: function() {
                    camera.position.set(0, 500, 500);
                    camera.lookAt(0, 0, 0);
                    controls.reset();
                },
                exportSettings: function() {
                    showExportModal();
                }
            };
            folderGlobal.add(params, 'wallOpacity', 0, 1).name('壁透明度').onChange(v => {
                walls.forEach(w => w.material.opacity = v);
            });
            folderGlobal.add(params, 'showWorkZone').name('作業半径表示').onChange(v => {
                workZones.forEach(z => z.visible = v);
            });
            folderGlobal.add(params, 'resetCamera').name('カメラリセット');
            
            // 重要: データ出力ボタン
            folderGlobal.add(params, 'exportSettings').name('★現在の配置を出力');
            
            folderGlobal.open();

            const folderFurniture = gui.addFolder('配置・サイズ (什器)');
            for (const key in furnitureData) {
                const data = furnitureData[key];
                const f = folderFurniture.addFolder(data.label);
                
                f.add(data, 'w', 10, 300).name('幅(W)').onChange(() => updateFurnitureMesh(key));
                f.add(data, 'd', 10, 300).name('奥行(D)').onChange(() => updateFurnitureMesh(key));
                f.add(data, 'x', -200, 200).name('位置 X').listen().onChange(() => updateFurnitureMesh(key));
                f.add(data, 'z', -200, 200).name('位置 Z').listen().onChange(() => updateFurnitureMesh(key));
            }
            folderFurniture.open();

            const folderPeople = gui.addFolder('配置 (人物)');
            peopleData.forEach((data, index) => {
                const f = folderPeople.addFolder(data.label);
                f.add(data, 'x', -200, 200).name('位置 X').listen().onChange(() => updatePersonMesh(index));
                f.add(data, 'z', -200, 200).name('位置 Z').listen().onChange(() => updatePersonMesh(index));
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
