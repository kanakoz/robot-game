<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CODE_MATRIX: CYBERPUNK OVERDRIVE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-pink: #ff00ff;
            --neon-cyan: #00ffff;
            --neon-green: #00ff00;
            --dark-bg: #050505;
        }

        body {
            background-color: var(--dark-bg);
            color: white;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            margin: 0;
            user-select: none;
            touch-action: none;
        }

        .cyber-panel {
            background: rgba(15, 15, 25, 0.9);
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            position: relative;
        }

        .editable-value {
            color: var(--neon-pink);
            font-weight: bold;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 4px;
            background: rgba(255, 0, 255, 0.1);
            border-radius: 4px;
            transition: all 0.2s;
            display: inline-block;
        }

        #game-canvas {
            image-rendering: pixelated;
            background: #000;
            border: 1px solid var(--neon-pink);
            touch-action: none;
            max-width: 100%;
            max-height: 100%;
        }

        .scanline {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        .code-syntax-keyword { color: #c678dd; }
        .code-syntax-const { color: #d19a66; }
        .code-syntax-comment { color: #5c6370; font-style: italic; }
        .code-syntax-string { color: #98c379; }

        .glitch-text {
            text-shadow: 2px 0 var(--neon-pink), -2px 0 var(--neon-cyan);
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #050505; }
        ::-webkit-scrollbar-thumb { background: var(--neon-cyan); }
    </style>
</head>
<body class="flex flex-col h-screen p-2 md:p-4">

    <!-- Header -->
    <header class="flex justify-between items-center mb-2 md:mb-4">
        <div>
            <h1 class="text-xl md:text-3xl font-bold glitch-text">CODE_MATRIX <span class="text-[10px] md:text-xs font-normal text-cyan-400">LIFF_v2.2</span></h1>
            <p id="user-status" class="text-[8px] md:text-[10px] text-gray-400 uppercase font-bold tracking-widest">
                USER: <span id="user-name" class="text-cyan-400">GUEST</span> [OFFLINE_MODE]
            </p>
        </div>
        <button id="reset-btn" class="px-2 py-1 md:px-4 md:py-2 border border-pink-500 text-pink-500 hover:bg-pink-500 hover:text-white transition-all text-[10px] md:text-xs font-bold uppercase">Reboot [再起動]</button>
    </header>

    <main class="flex flex-col md:flex-row flex-1 gap-2 md:gap-4 overflow-hidden">
        
        <!-- Code Editor Section -->
        <section class="h-1/3 md:h-auto md:w-2/5 flex flex-col gap-2">
            <div class="cyber-panel flex-1 p-3 md:p-6 overflow-y-auto">
                <div class="flex justify-between items-center mb-2 border-b border-cyan-900 pb-1">
                    <h2 class="text-cyan-400 text-[10px] md:text-sm flex items-center gap-2">
                        <span class="w-2 h-2 bg-cyan-400 inline-block animate-pulse"></span>
                        SYSTEM_CORE.js [プログラム編集]
                    </h2>
                </div>
                
                <div id="interactive-editor" class="text-[10px] md:text-sm leading-relaxed font-mono">
                    <!-- JS Content -->
                </div>
            </div>
        </section>

        <!-- Game Preview Section -->
        <section class="flex-1 flex flex-col gap-2 overflow-hidden">
            <div id="canvas-container" class="relative flex-1 cyber-panel overflow-hidden flex items-center justify-center p-1 bg-black">
                <div class="scanline"></div>
                <canvas id="game-canvas"></canvas>
                
                <!-- HUD -->
                <div class="absolute top-2 left-2 pointer-events-none">
                    <div class="text-[8px] md:text-[10px] text-cyan-400 mb-0 tracking-widest uppercase">Score [スコア]</div>
                    <div id="score-display" class="text-lg md:text-2xl font-bold tracking-tighter text-white">000000</div>
                </div>

                <div id="touch-hint" class="absolute bottom-4 left-1/2 -translate-x-1/2 text-[8px] md:text-[10px] text-gray-500 pointer-events-none animate-pulse">
                    DRAG TO MOVE & FIRE [ドラッグで移動・射撃]
                </div>
                
                <!-- Game Over Overlay -->
                <div id="overlay-msg" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-80 z-20 hidden text-center px-4">
                    <h3 class="text-2xl md:text-4xl font-bold text-pink-500 mb-2 glitch-text uppercase">System Failure</h3>
                    <p id="final-score-text" class="text-white mb-6 text-sm font-bold"></p>
                    <div class="flex flex-wrap gap-2 justify-center">
                        <button id="retry-btn" class="px-6 py-2 bg-cyan-500 text-black font-bold hover:bg-white transition-all text-xs uppercase">Recover [復旧]</button>
                        <button id="share-btn" class="px-6 py-2 bg-green-500 text-black font-bold hover:bg-white transition-all text-xs uppercase">Share on LINE [LINEで共有]</button>
                    </div>
                </div>
            </div>

            <div class="h-12 md:h-20 cyber-panel p-2">
                <div id="message-log" class="text-[8px] md:text-[10px] text-green-400 opacity-80 h-full overflow-y-auto font-mono">
                    > SYSTEM_INITIALIZED...<br>
                    > LIFF_READY_CHECKING...
                </div>
            </div>
        </section>

    </main>

    <script>
        // --- LIFF ID ---
        const LIFF_ID = "2008547267-ropNDWQn"; 

        // --- CONSTANTS ---
        const INTERNAL_WIDTH = 550;
        const INTERNAL_HEIGHT = 550;

        // --- CONFIG ---
        const options = {
            speed: [2.5, 5.0, 9.0],
            fireInterval: [500, 250, 100],
            color: ['#00ffff', '#ff00ff', '#00ff00'],
            spawnRate: [2000, 1000, 400],
            bulletType: ['STANDARD', 'WIDE', 'LASER']
        };

        const config = { speed: 0, fireInterval: 0, color: 0, spawnRate: 0, bulletType: 0 };

        // --- GAME STATE ---
        let gameActive = true;
        let score = 0;
        let lastTime = 0;
        let spawnTimer = 0;
        let lastFireTime = 0;
        
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = INTERNAL_WIDTH;
        canvas.height = INTERNAL_HEIGHT;

        const player = { x: INTERNAL_WIDTH/2 - 15, y: INTERNAL_HEIGHT-80, w: 30, h: 30 };
        let bullets = [];
        let enemies = [];
        let particles = [];
        
        const inputState = {
            keys: {},
            touch: { active: false, x: 0, y: 0 }
        };

        // --- LIFF LOGIC ---

        async function initLiff() {
            if (!LIFF_ID) {
                logMessage("WARNING: LIFF_ID が設定されていません。ローカルモードで実行します。");
                return;
            }

            try {
                await liff.init({ liffId: LIFF_ID });
                if (liff.isLoggedIn()) {
                    const profile = await liff.getProfile();
                    document.getElementById('user-name').innerText = profile.displayName.toUpperCase();
                    document.getElementById('user-status').innerHTML += ' <span class="text-green-400">[CONNECTED]</span>';
                    logMessage(`HELLO, ${profile.displayName}. AUTH_SUCCESS.`);
                } else {
                    logMessage("LOGIN_REQUIRED: 未ログイン状態です。");
                }
            } catch (err) {
                logMessage(`LIFF_INIT_ERROR: ${err.code} ${err.message}`);
            }
        }

        async function shareOnLine() {
            if (!liff.isLoggedIn()) {
                logMessage("LOGIN_REQUIRED: 共有の前にログインが必要です。");
                liff.login();
                return;
            }

            if (liff.isApiAvailable('shareTargetPicker')) {
                try {
                    const result = await liff.shareTargetPicker([
                        {
                            type: 'text',
                            text: `【CODE_MATRIX】\nSCORE: ${score.toString().padStart(6, '0')} を記録！\n\nプログラム変数を書き換え、さらなる高みを目指せ！\n#CodeMatrix #LIFF #GameProgramming`
                        }
                    ]);
                    if (result) {
                        logMessage("SHARE_SUCCESS [メッセージを送信しました]");
                    } else {
                        logMessage("SHARE_CANCELED [共有がキャンセルされました]");
                    }
                } catch (err) {
                    logMessage(`SHARE_ERR: ${err.message}`);
                }
            } else {
                logMessage("SHARE_UNAVAILABLE: この環境ではシェア機能が利用できません。");
                if (!liff.isInClient()) {
                    logMessage("HINT: LINEアプリ内のブラウザで開いてください。");
                }
            }
        }

        // --- INITIALIZATION ---

        async function init() {
            window.addEventListener('keydown', e => inputState.keys[e.code] = true);
            window.addEventListener('keyup', e => inputState.keys[e.code] = false);
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
            canvas.addEventListener('touchmove', handleTouch, { passive: false });
            canvas.addEventListener('touchend', () => { inputState.touch.active = false; }, { passive: false });

            document.getElementById('reset-btn').onclick = resetGame;
            document.getElementById('retry-btn').onclick = resetGame;
            document.getElementById('share-btn').onclick = shareOnLine;
            
            updateEditor();
            resetGame();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            await initLiff();

            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const size = Math.min(container.clientWidth, container.clientHeight) - 20;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
        }

        function handleTouch(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const scaleX = INTERNAL_WIDTH / rect.width;
            const scaleY = INTERNAL_HEIGHT / rect.height;
            
            inputState.touch.active = true;
            inputState.touch.x = (touch.clientX - rect.left) * scaleX;
            inputState.touch.y = (touch.clientY - rect.top) * scaleY;
        }

        function updateEditor() {
            const editor = document.getElementById('interactive-editor');
            const getVal = (key) => options[key][config[key]];

            editor.innerHTML = `
                <div><span class="code-syntax-comment">// --- リアルタイム・コード編集エンジン ---</span></div>
                <br>
                <div><span class="code-syntax-comment">// 自機の移動速度（高いほど高速）</span></div>
                <div><span class="code-syntax-keyword">const</span> <span class="code-syntax-const">SPEED</span> = <span class="editable-value" onclick="toggle('speed')">${getVal('speed').toFixed(1)}</span>;</div>
                <br>
                <div><span class="code-syntax-comment">// 弾を撃つ間隔（ミリ秒 / 低いほど連射）</span></div>
                <div><span class="code-syntax-keyword">let</span> fireRate = <span class="editable-value" onclick="toggle('fireInterval')">${getVal('fireInterval')}</span>;</div>
                <br>
                <div><span class="code-syntax-comment">// 弾丸の攻撃パターン</span></div>
                <div><span class="code-syntax-keyword">let</span> type = <span class="code-syntax-string">"<span class="editable-value" onclick="toggle('bulletType')">${getVal('bulletType')}</span>"</span>;</div>
                <br>
                <div><span class="code-syntax-comment">// プレイヤーのネオンカラー設定</span></div>
                <div>player.color = <span class="code-syntax-string">"<span class="editable-value" onclick="toggle('color')">${getVal('color')}</span>"</span>;</div>
                <br>
                <div><span class="code-syntax-keyword">function</span> <span class="code-syntax-const">enemySpawnSystem</span>() {</div>
                <div class="ml-4"><span class="code-syntax-comment">// 敵が出現する間隔（低いほど高密度）</span></div>
                <div class="ml-4">ms = <span class="editable-value" onclick="toggle('spawnRate')">${getVal('spawnRate')}</span>;</div>
                <div>}</div>
            `;
        }

        function toggle(key) {
            config[key] = (config[key] + 1) % options[key].length;
            updateEditor();
            logMessage(`UPDATE: ${key.toUpperCase()} -> ${options[key][config[key]]}`);
        }

        function logMessage(msg) {
            const log = document.getElementById('message-log');
            const time = new Date().toLocaleTimeString().split(' ')[0];
            log.innerHTML = `> [${time}] ${msg}<br>${log.innerHTML}`;
            log.scrollTop = 0;
        }

        function resetGame() {
            score = 0;
            enemies = [];
            bullets = [];
            particles = [];
            player.x = INTERNAL_WIDTH / 2 - 15;
            player.y = INTERNAL_HEIGHT - 80;
            gameActive = true;
            document.getElementById('overlay-msg').classList.add('hidden');
            document.getElementById('score-display').innerText = "000000";
            logMessage("RELOAD_CORE_SUCCESS [システム正常]");
        }

        // --- GAME ENGINE ---

        function createExplosion(x, y, color) {
            for(let i=0; i<6; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1.0,
                    color: color
                });
            }
        }

        function update(dt) {
            if (!gameActive) return;

            const speed = options.speed[config.speed];
            
            if (inputState.keys['ArrowLeft'] || inputState.keys['KeyA']) player.x -= speed;
            if (inputState.keys['ArrowRight'] || inputState.keys['KeyD']) player.x += speed;
            if (inputState.keys['ArrowUp'] || inputState.keys['KeyW']) player.y -= speed;
            if (inputState.keys['ArrowDown'] || inputState.keys['KeyS']) player.y += speed;

            if (inputState.touch.active) {
                const dx = inputState.touch.x - (player.x + player.w/2);
                const dy = (inputState.touch.y - 40) - (player.y + player.h/2);
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 5) {
                    player.x += (dx / dist) * speed;
                    player.y += (dy / dist) * speed;
                }
            }

            player.x = Math.max(0, Math.min(INTERNAL_WIDTH - player.w, player.x));
            player.y = Math.max(0, Math.min(INTERNAL_HEIGHT - player.h, player.y));

            const now = Date.now();
            const fireRate = options.fireInterval[config.fireInterval];
            if ((inputState.touch.active || inputState.keys['Space'] || inputState.keys['Enter']) && now - lastFireTime > fireRate) {
                const bType = options.bulletType[config.bulletType];
                const cx = player.x + player.w/2;
                if (bType === 'STANDARD') {
                    bullets.push({ x: cx - 2, y: player.y, w: 4, h: 12, vy: -12 });
                } else if (bType === 'WIDE') {
                    bullets.push({ x: cx - 2, y: player.y, w: 4, h: 12, vy: -10, vx: -2.5 });
                    bullets.push({ x: cx - 2, y: player.y, w: 4, h: 12, vy: -12, vx: 0 });
                    bullets.push({ x: cx - 2, y: player.y, w: 4, h: 12, vy: -10, vx: 2.5 });
                } else if (bType === 'LASER') {
                    bullets.push({ x: cx - 1, y: player.y, w: 2, h: 50, vy: -25 });
                }
                lastFireTime = now;
            }

            bullets.forEach((b, i) => {
                b.y += b.vy;
                if(b.vx) b.x += b.vx;
                if (b.y < -50) bullets.splice(i, 1);
            });

            spawnTimer += dt;
            if (spawnTimer > options.spawnRate[config.spawnRate]) {
                enemies.push({
                    x: Math.random() * (INTERNAL_WIDTH - 30),
                    y: -40, w: 30, h: 30,
                    vy: 2 + Math.random() * 3.5
                });
                spawnTimer = 0;
            }

            enemies.forEach((e, i) => {
                e.y += e.vy;
                if (e.y > INTERNAL_HEIGHT) enemies.splice(i, 1);

                if (e.x < player.x + player.w && e.x + e.w > player.x && e.y < player.y + player.h && e.y + e.h > player.y) {
                    gameActive = false;
                    document.getElementById('final-score-text').innerText = `TOTAL_SCORE: ${score.toString().padStart(6, '0')}`;
                    document.getElementById('overlay-msg').classList.remove('hidden');
                    createExplosion(player.x + player.w/2, player.y + player.h/2, '#fff');
                    logMessage("CORE_ERR: SYSTEM_OVERHEAT [コア融解]");
                }

                bullets.forEach((b, bi) => {
                    if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
                        createExplosion(e.x + e.w/2, e.y + e.h/2, options.color[config.color]);
                        enemies.splice(i, 1);
                        bullets.splice(bi, 1);
                        score += 100;
                        document.getElementById('score-display').innerText = score.toString().padStart(6, '0');
                    }
                });
            });

            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                if (p.life <= 0) particles.splice(i, 1);
            });
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT);

            ctx.strokeStyle = 'rgba(0, 255, 255, 0.07)';
            for(let i=0; i<INTERNAL_WIDTH; i+=50) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, INTERNAL_HEIGHT); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(INTERNAL_WIDTH, i); ctx.stroke();
            }

            if (gameActive) {
                const col = options.color[config.color];
                ctx.shadowBlur = 15; ctx.shadowColor = col;
                ctx.fillStyle = col;
                ctx.fillRect(player.x, player.y, player.w, player.h);
                ctx.fillStyle = '#fff';
                ctx.fillRect(player.x+8, player.y+8, player.w-16, player.h-16);
            }

            ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
            ctx.fillStyle = '#0ff';
            bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));

            ctx.shadowBlur = 10; ctx.shadowColor = '#f0f';
            ctx.fillStyle = '#f0f';
            enemies.forEach(e => {
                ctx.fillRect(e.x, e.y, e.w, e.h);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(e.x+5, e.y+5, e.w-10, e.h-10);
            });

            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function gameLoop(time) {
            const dt = time - lastTime;
            lastTime = time;
            update(dt || 0);
            draw();
            requestAnimationFrame(gameLoop);
        }

        window.onload = init;
    </script>
</body>
</html>
